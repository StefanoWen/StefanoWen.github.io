{"title":"攻击JWT的一些方式","date":"2019-11-18T16:29:49.000Z","date_formatted":{"ll":"Nov 18, 2019","L":"11/18/2019","MM-DD":"11-18"},"link":"/攻击JWT的一些方式","tags":["Web"],"updated":"2020-12-27T16:45:50.788Z","content":"<h1 id=\"关于jwt\">关于jwt<a title=\"#关于jwt\" href=\"#关于jwt\"></a></h1>\n<p>JWT的全称是Json Web Token。它遵循JSON格式，将用户信息加密到token里，服务器不保存任何用户信息，只保存密钥信息，通过使用特定加密算法验证token，通过token验证用户身份。基于token的身份验证可以替代传统的cookie+session身份验证方法。</p>\n<a id=\"more\"></a>\n<p>jwt由三个部分组成：<code>header</code>.<code>payload</code>.<code>signature</code></p>\n<h2 id=\"header部分\">header部分<a title=\"#header部分\" href=\"#header部分\"></a></h2>\n<p>header部分最常用的两个字段是<code>alg</code>和<code>typ</code>，<code>alg</code>指定了token加密使用的算法（最常用的为<em>HMAC</em>和<em>RSA</em>算法），typ`声明类型为JWT</p>\n<p>header通常会长这个样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t&quot;alg&quot; : &quot;HS256&quot;,</span><br><span class=\"line\">\t\t&quot;typ&quot; : &quot;jwt&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"payload部分\">payload部分<a title=\"#payload部分\" href=\"#payload部分\"></a></h2>\n<p>payload则为用户数据以及一些元数据有关的声明，用以声明权限，举个例子，一次登录的过程可能会传递以下数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t&quot;user_role&quot; : &quot;finn&quot;,    &#x2F;&#x2F;当前登录用户</span><br><span class=\"line\">    &quot;iss&quot;: &quot;admin&quot;,          &#x2F;&#x2F;该JWT的签发者</span><br><span class=\"line\">    &quot;iat&quot;: 1573440582,        &#x2F;&#x2F;签发时间</span><br><span class=\"line\">    &quot;exp&quot;: 1573940267,        &#x2F;&#x2F;过期时间</span><br><span class=\"line\">    &quot;nbf&quot;: 1573440582,         &#x2F;&#x2F;该时间之前不接收处理该Token</span><br><span class=\"line\">    &quot;domain&quot;: &quot;example.com&quot;,   &#x2F;&#x2F;面向的用户</span><br><span class=\"line\">    &quot;jti&quot;: &quot;dff4214121e83057655e10bd9751d657&quot;   &#x2F;&#x2F;Token唯一标识</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"signature部分\">signature部分<a title=\"#signature部分\" href=\"#signature部分\"></a></h2>\n<p>signature的功能是保护token完整性。</p>\n<p>生成方法为将header和payload两个部分联结起来，然后通过header部分指定的算法，计算出签名。</p>\n<p>抽象成公式就是</p>\n<p><code>signature = HMAC-SHA256(base64urlEncode(header) + '.' + base64urlEncode(payload), secret_key)</code></p>\n<p>值得注意的是，编码header和payload时使用的编码方式为<code>base64urlencode</code>，<code>base64url</code>编码是<code>base64</code>的修改版，为了方便在网络中传输使用了不同的编码表，它不会在末尾填充&quot;=“号，并将标准Base64中的”+“和”/“分别改成了”*“和”-&quot;。</p>\n<h2 id=\"完整token生成\">完整token生成<a title=\"#完整token生成\" href=\"#完整token生成\"></a></h2>\n<p>一个完整的jwt格式为(<code>header</code>.<code>payload</code>.<code>signature</code>)，其中header、payload使用base64url编码，signature通过指定算法生成。</p>\n<p>python的<code>Pyjwt</code>使用示例如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> jwt</span><br><span class=\"line\"></span><br><span class=\"line\">encoded_jwt = jwt.encode(&#123;<span class=\"string\">&#x27;user_name&#x27;</span>: <span class=\"string\">&#x27;admin&#x27;</span>&#125;, <span class=\"string\">&#x27;key&#x27;</span>, algorithm=<span class=\"string\">&#x27;HS256&#x27;</span>)</span><br><span class=\"line\">print(encoded_jwt)</span><br><span class=\"line\">print(jwt.decode(encoded_jwt, <span class=\"string\">&#x27;key&#x27;</span>, algorithms=[<span class=\"string\">&#x27;HS256&#x27;</span>]))</span><br></pre></td></tr></table></figure>\n<p>生成的token为</p>\n<p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code>.<code>eyJ1c2VyX25hbWUiOiJhZG1pbiJ9.</code>oL5szC7mFoJ_7FI9UVMcKfmisqr6Qlo1dusps5wOUlo`</p>\n<h1 id=\"攻击方式\">攻击方式<a title=\"#攻击方式\" href=\"#攻击方式\"></a></h1>\n<h2 id=\"加密算法\">加密算法<a title=\"#加密算法\" href=\"#加密算法\"></a></h2>\n<ol>\n<li>空加密算法</li>\n</ol>\n<p>JWT支持使用空加密算法，可以在header中指定alg为<code>None</code></p>\n<p>这样的话，只要把signature设置为空（即不添加signature字段），提交到服务器，任何token都可以通过服务器的验证。举个例子，使用以下的字段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;alg&quot; : &quot;None&quot;,</span><br><span class=\"line\">\t&quot;typ&quot; : &quot;jwt&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;user&quot; : &quot;Admin&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成的完整token为<code>ew0KCSJhbGciIDogIk5vbmUiLA0KCSJ0eXAiIDogImp3dCINCn0.ew0KCSJ1c2VyIiA6ICJBZG1pbiINCn0</code></p>\n<p>(header+‘.’+payload，去掉了’.'+signature字段)</p>\n<p>空加密算法的设计初衷是用于调试的，但是如果某天开发人员脑阔瓦特了，在生产环境中开启了空加密算法，缺少签名算法，jwt保证信息不被篡改的功能就失效了。攻击者只需要把alg字段设置为None，就可以在payload中构造身份信息，伪造用户身份。</p>\n<ol start=\"2\">\n<li>修改HMAC加密算法为RSA</li>\n</ol>\n<p>JWT中最常用的两种算法为<code>HMAC</code>和<code>RSA</code>。</p>\n<p><code>HMAC</code>是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）的缩写，它是一种对称加密算法，使用相同的密钥对传输信息进行加解密。</p>\n<p><code>RSA</code>则是一种非对称加密算法，使用私钥加密明文，公钥解密密文。</p>\n<p>在HMAC和RSA算法中，都是使用私钥对<code>signature</code>字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token。</p>\n<p>现在我们假设有这样一种情况，一个Web应用，在JWT传输过程中使用RSA算法，密钥<code>pem</code>对JWT token进行签名，公钥<code>pub</code>对签名进行验证。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;alg&quot; : &quot;RS256&quot;,</span><br><span class=\"line\">\t&quot;typ&quot; : &quot;jwt&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通常情况下<code>pem</code>是无法获取到的，但是<code>pub</code>却可以很容易通过某些途径读取到，这时，将JWT的加密算法修改为HMAC，即</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;alg&quot; : &quot;HS256&quot;,</span><br><span class=\"line\">\t&quot;typ&quot; : &quot;jwt&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同时使用获取到的公钥<code>pub</code>作为算法的密钥，对token进行签名，发送到服务器端。</p>\n<p>服务器端会将RSA的公钥（<code>pub</code>）视为当前算法（HMAC）的密钥，使用HS256算法对接收到的签名进行验证。</p>\n<blockquote>\n<p>REF:</p>\n<p><a href=\"https://skysec.top/2018/05/19/2018CUMTCTF-Final-Web/#Pastebin/\">https://skysec.top/2018/05/19/2018CUMTCTF-Final-Web/#Pastebin/</a></p>\n</blockquote>\n<h2 id=\"爆破密钥\">爆破密钥<a title=\"#爆破密钥\" href=\"#爆破密钥\"></a></h2>\n<p>俗话说，有密码验证的地方，就有会爆破。</p>\n<p>不过对 JWT 的密钥爆破需要在一定的前提下进行：</p>\n<ul>\n<li>知悉JWT使用的加密算法</li>\n<li>一段有效的、已签名的token</li>\n<li>签名用的密钥不复杂（弱密钥）</li>\n</ul>\n<p>所以其实JWT 密钥爆破的局限性很大。</p>\n<p>相关工具：<a href=\"https://github.com/brendan-rius/c-jwt-cracker\" target=\"_blank\">c-jwt-cracker</a></p>\n<p>以下是几个使用示例</p>\n<p><img src=\"https://raw.githubusercontent.com/StefanoWen/img/master/img/20191115162604.png\" alt=\"\" class=\"φcx\"></p>\n<p>可以看到简单的字母数字组合都是可以爆破的，但是密钥位数稍微长一点或者更复杂一点的话，爆破时间就会需要很久。</p>\n<h2 id=\"修改kid参数\">修改KID参数<a title=\"#修改kid参数\" href=\"#修改kid参数\"></a></h2>\n<p><code>kid</code>是jwt header中的一个可选参数，全称是<code>key ID</code>，它用于指定加密算法的密钥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;alg&quot; : &quot;HS256&quot;,</span><br><span class=\"line\">\t&quot;typ&quot; : &quot;jwt&quot;,</span><br><span class=\"line\">\t&quot;kid&quot; : &quot;&#x2F;home&#x2F;jwt&#x2F;.ssh&#x2F;pem&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为该参数可以由用户输入，所以也可能造成一些安全问题。</p>\n<h3 id=\"任意文件读取\">任意文件读取<a title=\"#任意文件读取\" href=\"#任意文件读取\"></a></h3>\n<p><code>kid</code>参数用于读取密钥文件，但系统并不会知道用户想要读取的到底是不是密钥文件，所以，如果在没有对参数进行过滤的前提下，攻击者是可以读取到系统的任意文件的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;alg&quot; : &quot;HS256&quot;,</span><br><span class=\"line\">\t&quot;typ&quot; : &quot;jwt&quot;,</span><br><span class=\"line\">\t&quot;kid&quot; : &quot;&#x2F;etc&#x2F;passwd&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"sql注入\">SQL注入<a title=\"#sql注入\" href=\"#sql注入\"></a></h3>\n<p><code>kid</code>也可以从数据库中提取数据，这时候就有可能造成SQL注入攻击，通过构造SQL语句来获取数据或者是绕过signature的验证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;alg&quot; : &quot;HS256&quot;,</span><br><span class=\"line\">\t&quot;typ&quot; : &quot;jwt&quot;,</span><br><span class=\"line\">\t&quot;kid&quot; : &quot;key11111111&#39; || union select &#39;secretkey&#39; -- &quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"命令注入\">命令注入<a title=\"#命令注入\" href=\"#命令注入\"></a></h3>\n<p>对<code>kid</code>参数过滤不严也可能会出现命令注入问题，但是利用条件比较苛刻。如果服务器后端使用的是Ruby，在读取密钥文件时使用了<code>open</code>函数，通过构造参数就可能造成命令注入。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;/path/to/key_file|whoami&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>对于其他的语言，例如php，如果代码中使用的是<code>exec</code>或者是<code>system</code>来读取密钥文件，那么同样也可以造成命令注入，当然这个可能性就比较小了。</p>\n<h2 id=\"修改jku/x5u参数\">修改JKU/X5U参数<a title=\"#修改jku/x5u参数\" href=\"#修改jku/x5u参数\"></a></h2>\n<p><code>JKU</code>的全称是&quot;JSON Web Key Set URL&quot;，用于指定一组用于验证令牌的密钥的URL。类似于<code>kid</code>，<code>JKU</code>也可以由用户指定输入数据，如果没有经过严格过滤，就可以指定一组自定义的密钥文件，并指定web应用使用该组密钥来验证token。</p>\n<p><code>X5U</code>则以URI的形式数允许攻击者指定用于验证令牌的<strong>公钥证书或证书链</strong>，与<code>JKU</code>的攻击利用方式类似。</p>\n<h2 id=\"其他方式\">其他方式<a title=\"#其他方式\" href=\"#其他方式\"></a></h2>\n<h3 id=\"信息泄露\">信息泄露<a title=\"#信息泄露\" href=\"#信息泄露\"></a></h3>\n<p>JWT保证的是数据传输过程中的完整性而不是机密性。</p>\n<p>由于payload是使用<code>base64url</code>编码的，所以相当于明文传输，如果在payload中携带了敏感信息（如存放密钥对的文件路径），单独对payload部分进行<code>base64url</code>解码，就可以读取到payload中携带的信息。</p>\n","next":{"title":"毕设开发手记-2019/4/11","link":"/毕设开发手记-2019-4-11"},"plink":"https://pineswen.tk//攻击JWT的一些方式/","toc":[{"id":"关于jwt","title":"关于jwt","index":"1","children":[{"id":"header部分","title":"header部分","index":"1.1"},{"id":"payload部分","title":"payload部分","index":"1.2"},{"id":"signature部分","title":"signature部分","index":"1.3"},{"id":"完整token生成","title":"完整token生成","index":"1.4"}]},{"id":"攻击方式","title":"攻击方式","index":"2","children":[{"id":"加密算法","title":"加密算法","index":"2.1"},{"id":"爆破密钥","title":"爆破密钥","index":"2.2"},{"id":"修改kid参数","title":"修改KID参数","index":"2.3","children":[{"id":"任意文件读取","title":"任意文件读取","index":"2.3.1"},{"id":"sql注入","title":"SQL注入","index":"2.3.2"},{"id":"命令注入","title":"命令注入","index":"2.3.3"}]},{"id":"修改jku/x5u参数","title":"修改JKU&#x2F;X5U参数","index":"2.4"},{"id":"其他方式","title":"其他方式","index":"2.5","children":[{"id":"信息泄露","title":"信息泄露","index":"2.5.1"}]}]}]}